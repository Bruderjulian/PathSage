function e(e){return"object"!=typeof e||null===e}function t(e){if("object"!=typeof e||null===e)throw SyntaxError("Invalid Object Type")}const r=Object.hasOwn||Object.call.bind(Object.hasOwnProperty),n=Array.isArray||function(e){return e&&e.constructor===Array},o=new Set(["this","__proto__","prototype","constructor"]),l=new Set(["['']",'[""]',"[``]",""]),i=/\.|\[|\]|\"|\'|\s/;function f(e,t){let r=Object.keys(e);if(0===r.length)return t?[t]:[];const n=[];let o,l,u;for(o of r)if(l=e[o],u=""===t?o:i.test(o)?o.includes("'")?`${t}.["${o}"]`:`${t}.['${o}']`:Array.isArray(e)?`${t}[${o}]`:`${t}.${o}`,"object"==typeof l&&null!==l)n.push(...f(l,u));else n.push(u);return n}var u={},c=false,s=0,a=4096;function h(e){if(r(u,e))return u[e].slice(0)||[];if(++s>a&&-1!==a)u={},s=1;if(n(e))return(u[e]=e.reverse()).slice(0);if("string"!=typeof e)throw TypeError("Invalid Notation Type");return(u[e]=function(e){if(0===e.length)return[];const t=[],r=/\[\s*(\d+)(?=\s*])|\[\s*(["'`])((?:\\.|(?!\2).)*)\2\s*]|[\w$]+/g;let i,f;while(i=r.exec(e)){if(f=i[1]||i[3]||i[0],!l.has(f)){if(!c&&o.has(f))throw SyntaxError("Disallowed Key encountered");t.push(f)}}if(!n(t))throw SyntaxError("Could not tokenize Notation");return t.reverse()}(e)).slice(0)}export function set(r,n,o){t(r);n=h(n);if(0===n.length)return;for(let t=n.length;--t>0;){if(e(r=r[n[t]])){throw EvalError("Could not fully evaluate the object path")}}r[n[0]]=o}export function get(r,n){t(r);n=h(n);if(0===n.length)return r;for(let t=n.length;--t>0;)if(e(r=r[n[t]]))throw EvalError("Could not fully evaluate the object path");return r[n[0]]}export function has(r,n,o=false){t(r);n=h(n);for(var l,i,f=n.length;f-- >0;){if(!e(i=r[l=n[f]])&&0!==f||void 0!==i){r=i;continue}if(o)return{success:false,depth:n.length-f-1,left:++f,key:l,currentObject:r};return false}return o?{success:true,depth:n.length-f-1,left:++f,key:null,currentObject:r}:true}export function remove(r,o){t(r);o=h(o);if(0===o.length){for(const e of Object.keys(r))delete r[e];return}for(let t=o.length;--t>0;){if(e(r=r[o[t]])){throw EvalError("Could not fully evaluate the object path")}}if(n(r)){const e=parseInt(o[0],10);if(isNaN(e))throw SyntaxError("key is not a Number");r.splice(e,1)}else delete r[o[0]]}export function create(n={},o=""){t(n);o=h(o);if(0===o.length)return;for(let t=o.length,r;--t>0;){if(e(obj[n=o[t]]))n[r]={};n=n[r]}if(!r(n,o=o[0]))n[o]={}}export function keys(e){return t(e),f(e,"")}export function getPaths(e){return t(e),f(e,"")}export function clearCache(){u={};s=0}export function configure(t={}){if(e(t)||n(t))throw TypeError("Invalid Options Type");if("boolean"==typeof t.allowKeys)c=t.allowKeys;let r=t.cacheSize;if("string"==typeof r)r=parseFloat(r,10);if("number"==typeof r&&!isNaN(r)&&r===Math.floor(r)&&r>=-1&&r<=Number.MAX_SAFE_INTEGER){a=t.cacheSize}}